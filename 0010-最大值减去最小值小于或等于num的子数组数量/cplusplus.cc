#include <iostream>
#include <vector>
#include <stack>
#include <deque>
#include <assert.h>
using namespace std;

/**
    最大值减去最小值小于等于num的子数组数量
    题目：给定数组arr和整数num，共返回有多少个子数组满足如下情况：
        max(arr[i..j]) - min(arr[i..j]) <= num
    max(arr[i..j])表示子数组arr[i..j]中的最大值，min(arr[i..j])表示子数组arr[i..j]中的最小值。
    要求：如果数组长度为N，时间复杂度为O(N)，额外空间复杂度为O(N)
*/
/**
    解题思路：
    1. 根据题目的要求，我们很容易可以联想到之前的一个问题-生成窗口最大值数组，只不过那个问题的
    窗口大小固定，而本题中窗口并不固定。
    2. 另外由于本题要求解子数组的最大值和最小值的差值，因此我们需要申请两个双端队列，分别用来
    维护在窗口滑动的大小变化时的最大值和最小值。
    3. 除此之外，我们还有2个重要的结论：
        a. 如果子数组arr[i..j]满足条件，即max(arr[i..j]) - min(arr[i..j]) <= num，那么arr[i..j]
        中的每一个子数组，即arr[k..l](i <= k <= l <= j)都满足条件。这时因为它的子数组不可能会出
        现比它的最小值还小或者最大值还大的情况，也就不可能会不满足条件了。
        b. 如果子数组arr[i..j]不满足条件，那么所有包含arr[i..j]的子数组，
        即arr[k..l](k <= i <= j <= l)也必定不满足条件。原因是不论包含它的数组新的元素是否可以满
        足条件，只要arr[i..j]不满足条件，那么包含它的数组也永远不会满足。
    算法设计如下：
    1. 生成两个双端队列qmax和qmin，两个整型变量i和j，用来表示子数组的范围，生成整型变量res，
    用来表示所有满足条件的子数组数量；
    2. 子数组都从数组的开始位置开始移动，最开始要先保持i不动，不断向右移动j，即窗口一直在扩大，
    同时不断更新qmax和qmin。重点来了：只要出现arr[i..j]不满足条件的情况发生，j就停止向右扩展。
    此时j-1之前直到i之间的子数组都是满足条件的。也就是说所有以i为第一个元素的子数组，满足条件
    的数量为(j - i)个，因此令res += (j - i)。(特别注意：根据上面给出的结论1，这里并没有把
    arr[i..j]的所有子数组都加上，这是因为这里面的有些子数组有可能会跟后续i向右移动后的有重复，
    因此我们这里只累加以i为第一个元素的子数组)
    上的，那是因为)
    3. 完成上述处理后，将i向右移动一个位置，并更新qmax和qmin。然后重复步骤2.
    4. 根据步骤2和步骤3，依次求出以arr[0]、arr[1]、...、arr[N - 1]作为第一个元素的子数组中满
    足条件的数量分别有多少个，累加起来的数量就是最终的结果。
*/

static int getSubArrayNum(vector<int>& arr, int num) {
    assert(!arr.empty());
    deque<int> qmax, qmin;
    int i, j;
    int res =  0;
    // 初始状态：qmax和qmin都为空，因此直接将第一个元素下标压入队列即可，然后我们直接从第二个元素
    // 开始迭代。
    qmax.push_back(0);
    qmin.push_back(0);
    for (i = 0, j = 1; i < arr.size(); i++) {
        // 每次更新完i后，相当于窗口的左边界右移，因此我们还需要更新qmax和qmin队列，如果队列的
        // 左边界(最大/小值所在下标)比当前窗口的左边界小，说明其在窗口界外，我们需要删除该元素
        // 来更新qmax和qmin。
        if (!qmax.empty() && qmax.front() < i) {
            qmax.pop_front();
        }
        if (!qmin.empty() && qmin.front() < i) {
            qmin.pop_front();
        }
        // 以i为左边界保持不变，初始状态时，j = i，单元素的子数组一定是满足条件的，因为其差值为
        // 0，因此我们只要不断向右移动j直到向右迭代到恰好不满足条件的位置，这样这个位置前面的子
        // 数组就是全部满足条件的。
        for (; j < arr.size(); j++) {
            // 1. 先更新qmax
            // Tips: 此处empty()检查主要是处理当前待入队的元素是最大值的情况，因为那样会把qmax内
            // 的元素排干从而为空，因此加此条件来作为其终止迭代的条件)
            // Note: 此处还有个注意点，对于队尾保存的值跟待入队的值比较时，还应包含相等的情况，
            // 因为按照此设计的特点，如果两个最值相等，右侧的值应该取代左侧的值保存下来，因为窗
            // 口是向右滑动，这样当左侧的值被窗口滑出界时，其右侧保存的值还有效，而这个是必须的，
            // 否则会导致计算错误。
            while (!qmax.empty() && arr[qmax.back()] <= arr[j]) {
                qmax.pop_back();
            }
            // Tips: 这里把所有比它小的元素都排出后只需要把它压入队列即可。原因是队列始终保证其
            // 的元素按照数组顺序排列，因此既然下标靠后的元素比它们大，那即使窗口向后滑动，下标
            // 靠后的元素始终比这些元素要更晚被窗口左边界排出，因此最大值永远不可能是那些元素，
            // 也因此我们不需要保存这些元素在队列中。
            qmax.push_back(j);
            // 2. 然后更新qmin
            while (!qmin.empty() && arr[qmin.back()] >= arr[j]) {
                qmin.pop_back();
            }
            // Tips: 参见qmax所述
            qmin.push_back(j);
            // 3. 检查是否满足条件，只要不满足条件就累加符合条件的子数组数目，并跳出当前j循环。
            if (arr[qmax.front()] - arr[qmin.front()] > num) {
                break;
            }
        }
        // 4. 累加操作应该在此处理，因为有可能是全序列都满足，这样根本不会触发上面不满足条件的
        // 情况，从而导致最后结果为0。
        res += (j - i);
    }
    return res;
}

int main(int nargs, char** argv) {
    vector<int> arr = {3, 5};
    cout << "The num is " << getSubArrayNum(arr, 2) << endl;
    return 0;
}
